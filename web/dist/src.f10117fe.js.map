{"version":3,"sources":["src/models/User.ts","src/index.ts"],"names":[],"mappings":";;;;;ACAA,IAAA,MAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA,ADOA,ICPM,ADON,ICPU,ADOV,GCPa,ADOb,ICPiB,MAAA,CAAA,EDOjB,ECPqB,CAAC,SDOtB;ECPwB,ADetB,ICf0B,EAAE,GDe5B,IAAA,CCfoC,ADehB,IAAe,EAAA;ECfG,EDelB,CCfqB,EAAE,CDevB,CAAA,IAAI,GAAJ,IAAI;ACfqB,CAAE,CAAC,EDQhD;ACNF,IDOE;ACNF,IAAI,ADOF,CCPG,GAAG,CAAC;EAAE,EDQT,ECRa,EAAE;AAAK,CAAE,CAAC,EDSvB;ACPF,IDQE,IAAA,CAAA,MAAM,GAAkC,CAAA,CAAE;ACP5C,EDSwC,KCTjC,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;AAC/B,EDUE,KCVK,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAE9B,EDSE,IAAA,CAAA,SAAA,CAAA,GAAG,GAAH,UAAI,QAAgB,EAAA;ACRtB,IAAI,ADSA,CCTC,EAAE,CAAC,GDSG,IAAI,CCTC,ADSA,ECTE,EDSE,CAAC,QAAQ,CCTX,ADSY;ECR5B,ADSA,CAAC,MCTM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,ADSA;ACRF,EDSE,ECTE,CAAC,CDSH,CCTK,ADSL,CCTM,QAAQ,ADSd,CAAA,CCTgB,EDSb,GAAH,OCTgB,GDSZ,MAAiB,EAAA;ECRrB,EDSE,KCTK,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;AAC5B,CAAC,CAAC,EDSE;ACRJ,IAAI,ADSA,CCTC,EAAE,CAAC,MAAM,EAAE,YAAA;EACd,EDSE,KCTK,CAAC,GAAG,CAAC,oBAAoB,CAAC;AACnC,CAAC,CAAC,EDSE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC;ACPpC,EDQE,CAAC;ACPH,EDQE;ACNF,EDOE;ACNF,EDOE,ECPE,CAAC,CDOH,CAAA,KCPU,CAAC,GDOX,CAAA,EAAE,ECPiB,CAAC,ADOpB,UAAG,SAAiB,EAAE,QAAkB,EAAA;IACtC;IACA;IACA;IACA,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,EAAE;IAC7C;IACA,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC;IACvB;IACA,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,QAAQ;EACnC,CAAC;EAED;EACA,IAAA,CAAA,SAAA,CAAA,OAAO,GAAP,UAAQ,SAAiB,EAAA;IACvB;IACA,IAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC;IACvC;IACA,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;MACtC;IACF;IACA;IACA,QAAQ,CAAC,OAAO,CAAC,UAAC,QAAQ,EAAA;MACxB,QAAQ,CAAA,CAAE;IACZ,CAAC,CAAC;EACJ,CAAC;EACH,OAAA,IAAC;AAAD,CAhDA,CAAA,CAAA;AAAa,OAAA,CAAA,IAAA,GAAA,IAAA","file":"src.f10117fe.js","sourceRoot":"..","sourcesContent":["interface UserProps {\r\n  // ? - it can have a 'name' or 'age' but not a must!\r\n  name?: string;\r\n  age?: number;\r\n}\r\n\r\n// Type Alias for a Empty Function (no Arg and no return values)\r\ntype Callback = () => void;\r\n\r\nexport class User {\r\n  // Stores all the different Events that get registered\r\n  // all the 'key's' are going to be Strings, and the Value is going to be an Array of Callback Functions\r\n  // [key: string] - because I don't know yet what Properties this Object is going to have\r\n  // I don't need to pass 'events' when creating an instance of the User, that's why I will NOT add it to the 'constructor'\r\n  // I only going to allow 'events' to be registered after a User has been created. (that's why I added this as a sepparate Property)\r\n  events: { [key: string]: Callback[] } = {};\r\n\r\n  constructor(private data: UserProps) {}\r\n\r\n  // will be called with some propName - name of the property that I try to retrieve\r\n  get(propName: string): number | string {\r\n    return this.data[propName];\r\n  }\r\n  // when I call set(), it will then pass in some Object that contains all the different updates that I want to make to the User\r\n  set(update: UserProps): void {\r\n    // Object.assign() is going to take 2 Objects, the 2nd Object that I pass in is going to have all of its Properties taken and copied over to the 1st Object\r\n    // data - is the Object that records all the information about a particular User\r\n    // then, take the 'update Object' that I passed in and pass it in as this 2nd Argument\r\n    // Essentially, this basically says take all the Properties on 'update' and all the values in there and just copy paste them over onto this 'data' and override all the Properties on this 'data'.\r\n    Object.assign(this.data, update);\r\n  }\r\n  // called with some 'eventName' of Event that is a String\r\n  // 2nd Arg - callback function\r\n  on(eventName: string, callback: Callback): void {\r\n    // when it first creates a User, it will look at 'this.events' and look up 'eventName' that's going to give possibly 'undefined', if it does, then it will just fall back to assigning an Empty Array to 'handlers'\r\n    // when 'this.events[eventName]' is defined, then it will take the Array of Callbacks that I've had already created and assign it to 'handlers' instead.\r\n    // either way 'handlers' is going to be an Array\r\n    const handlers = this.events[eventName] || [];\r\n    // after getting that Array, it will add in the brand new Callback that was passed into the 'on()'\r\n    handlers.push(callback);\r\n    // then it will take the 'handlers' Array and assign it back to 'this.events' Object\r\n    this.events[eventName] = handlers;\r\n  }\r\n\r\n  // will trigger all the different callbacks registered to some particular Event\r\n  trigger(eventName: string): void {\r\n    // checks if it has some registered events with this given 'eventName'\r\n    const handlers = this.events[eventName];\r\n    // if 'handlers' is defined and if it is an Array, then 'return' early\r\n    if (!handlers || handlers.length === 0) {\r\n      return;\r\n    }\r\n    // if there are some defined 'handlers' Array, then call all those Callbacks right after I have that early return\r\n    handlers.forEach((callback) => {\r\n      callback();\r\n    });\r\n  }\r\n}\r\n","import { User } from './models/User';\r\n\r\nconst user = new User({ name: 'myname', age: 20 });\r\n\r\n// Update the 'name' and 'age'\r\nuser.set({ name: 'Max' });\r\n\r\n// 'name' and 'age' because => get(propName: string)\r\nconsole.log(user.get('name')); // Max\r\nconsole.log(user.get('age')); // 20\r\n\r\n// testing adding the events\r\nuser.on('change', () => {\r\n  console.log('Change #1'); // 2 outputs because of user.trigger('change') OUTPUT: Change #1\r\n});\r\nuser.on('change', () => {\r\n  console.log('Change #2'); // 2 outputs because of user.trigger('change') OUTPUT: Change #2\r\n});\r\nuser.on('save', () => {\r\n  console.log('Save was triggered');\r\n});\r\n\r\n// for making sure it works, Ill check the entire 'user' and look fot it's 'events property' and check that it has a 'change property' with at least 1 registered function\r\n// console.log(user); // User {data: {…}, events: {…}} (inside 'events' there is a Key 'change' with 1 registed Function with it)\r\n\r\n// triggering Events\r\nuser.trigger('change');\r\n"]}